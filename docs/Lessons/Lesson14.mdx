---
sidebar_position: 16
---

# Lesson 13 - Express and MongoDB

## Preparation

### Setup

```jsx
const express = require("express");
const port = process.env.PORT || 3000;
const app = express();

var router = express.Router()

app.use(express.json()); // Utilities for request bodies
app.use(express.urlencoded({ extended: true })); // Utilities for query params

// GET Requests

router.get("/", (req, res) => {
  // homepage
  res.send("stupidDB API");
});

router.get("/info/index", (req, res) => {
  // get the current index
  res.send({ counter: counter });
});

router.get("/info/capacity", (req, res) => {
  // get the capacity
  res.send({ capacity: Object.keys(stupidDB).length });
});

router.get("/db/all", (req, res) => {
  // get all items from the db
  res.send(stupidDB);
});

// Combining endpoints into a single "route"

router.route("/db/:id")
	.get((req, res) => {
	  // get a certain item from the db
	  const id = req.params.id;
	  if (id in stupidDB) {
	    res.send(stupidDB[id]);
	  } else {
	    res.send({ error: "no object found with this id" });
	  }
	}).
	.put("/db/:id", (req, res) => {
	  const id = req.params.id;   // get the index of the data to update
	  const item = req.body.item; // access the body of the request which holds new data
	  if (id in stupidDB) {
	    stupidDB[id] = item;      // insert destructively
	    res.send({ newItem: item });
	  } else {
	    res.send({ error: "no object found with this id" });
	  }
	});
	.delete("/db/:id", (req, res) => {})

// POST Requests

router.post("/db", (req, res) => {
  console.log(req);
  const item = req.body.item; // access our request body
  stupidDB[counter] = item;   // add body item at index
  counter += 1;               // increment counter
  res.send(`POST Request Successful. Item placed: ${item}`); // Send HTTP response
});

// Server Setup

app.use('/', router)

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

Let us first setup the MongoDB. Use homebrew to install mongoDB. Here are the macOS instructions. Here is the link to the instructions in general for other systems (Linux and Windows) [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/) .

`brew install mongodb-community`

```bash
$ brew tap mongodb/brew
$ brew install mongodb-community
$ brew services start mongodb-community
```

Now type `mongo` to start the mongo shell to interact with the database.

Let's create a database called `database-tutorial`. Use the `use` keyword in the mongo shell.

```bash
$ use database-tutorial
```

Now, we have the database ready in our computer. To connect with mongoDB, let's install mongoose, a library that helps mongoDB easier to use in express.

```bash
$ npm install mongoose --save
```

Now add the following lines to the server.js file, it serves to connect with the mongoDB database that we just set up.

```jsx
const mongoose = require('mongoose')
const url = 'mongodb://127.0.0.1:27017/database-tutorial'

mongoose.connect(url, { useNewUrlParser: true })

const db = mongoose.connection

db.once('open', _ => {
  console.log('Database connected:', url)
})

db.on('error', err => {
  console.error('connection error:', err)
})
```

When you rerun the server.js script, you can see the following message: `Database connected: mongodb://127.0.0.1:27017/database-tutorial`, which means you have successfully connected to the database.

# Create MongoDB Model

Let's first create a model for our mongoDB database. We first need to create a schema. MongoDB will automatically add a `_id` field to schema. Thus, we only need to create a content field. 

After creating the schema, use `mongoose.model` to create a TODO model.

```jsx
const Schema = mongoose.Schema

const item = new Schema({
  title: String
	task: String,
	date: String,
	urgency: Number,
})

const TODO = mongoose.model("TODO", item)
```

# CURD Operations for MongoDB & Express

## Create

Let's first implement the endpoint for creating a new TODO.

To create a new TODO, we call `new TODO()`, and by passing in an object that corresponds to the schema, we can successfully create a todo object. To save this todo object into the database, use `todo.save()`.

After we create and save the todo, we can access the `todo._id` field that mongoDB automatically provides.

```jsx
router.post("/db", (req, res) => {
    const todo = new TODO({        // Create TODO item with the appropriate fields
        title: req.body.title,
        task: req.body.task,
        date: req.body.date,
        urgency: req.body.urgency,
    });
    todo.save((error, document) => {
        if (error) {
            res.json({ status: "failure" });
        } else {
            res.json({               // Save TODO item to the database
                status: "success",
                id: todo._id,
                content: req.body
            });
        }
    })
});
```

Try it out in the postman, you can see that the new todo is created successfully.

![image5](../assets/Lesson14/image5.png)

## Retrieve

Let's continue to build upon the existing APIs!

We can use `.find()` to retrieve all todos.

```jsx
router.get("/db/all", (req, res) => {
		TODO.find().then((todos) => {
      res.json({ message: 'Return all todos.', todos: todos});
    })
});
```

Test it out in the postman api request, you would get something like this.

![image1](../assets/Lesson14/image1.png)

Let's see whether we can retrieve the content of only one todo. `.findById()` method allows you to find the object in the database given an ID. 

```jsx
router.route("/db/:id")
	.get((req, res) => {
	  // get a certain item from the db
		TODO.findById(req.params.id, (error, todo) => {
			if (error) {
					res.json({ status: "failure" })
			} else {
					res.json(todo)
	  }
	}).
	.put("/db/:id", (req, res) => {
	  const id = req.params.id;   // get the index of the data to update
	  const item = req.body.item; // access the body of the request which holds new data
	  if (id in stupidDB) {
	    stupidDB[id] = item;      // insert destructively
	    res.send({ newItem: item });
	  } else {
	    res.send({ error: "no object found with this id" });
	  }
	});
	.delete("/db/:id", (req, res) => {})
```

Test it out using Postman by adding one of your todo id. You should receive this from the API.

![img2](../assets/Lesson14/image2.png)

## Update

To update a TODO, we use the method called `findByIdAndUpdate()`.

```jsx
router.route("/db/:id")
	.get((req, res) => {
	  // get a certain item from the db
	  const id = req.params.id;
		TODO.findById(req.params.id, (error, todo) => {
			if (error) {
					res.json({ status: "failure" })
			} else {
					res.json(todo)
	  }
	}).
	.put("/db/:id", (req, res) => {
	  TODO.findByIdAndUpdate(req.params.id, req.body, (error, todo) => {
			if (error) {
				res.json({ status: "failure" })
			else {
				res.json(todo)
			}
	});
	.delete("/db/:id", (req, res) => {})

```

![img3](../assets/Lesson14/image3.png)

## Delete

To delete a TODO, we use the method called `findByIdAndDelete()`.

```jsx
router.route("/db/:id")
	.get((req, res) => {
		TODO.findById(req.params.id, (error, todo) => {
			if (error) {
					res.json({ status: "failure" })
			} else {
					res.json(todo)
	  }
	}).
	.put("/db/:id", (req, res) => {
	  TODO.findByIdAndUpdate(req.params.id, req.body, (error, todo) => {
			if (error) {
				res.json({ status: "failure" })
			else {
				res.json(todo)
			}
	});
	.delete("/db/:id", (req, res) => {
		TODO.findByIdAndDelete(req.params.id, (error, todo) => {
			if (error) {
				res.json({ status: "failure"})
			} else {
				res.json(todo)
			}
	})
```

![img4](../assets/Lesson14/image4.png)

# Final Product

```jsx
const express = require("express");
const port = process.env.PORT || 3000;
const app = express();

var router = express.Router()

app.use(express.json());                         // Utilities for request bodies
app.use(express.urlencoded({ extended: true })); // Utilities for query params

// begin mongoose setup
const mongoose = require('mongoose')
const url = 'mongodb://127.0.0.1:27017/database-tutorial'

mongoose.connect(url, { useNewUrlParser: true })

const db = mongoose.connection
db.once('open', _ => {
  console.log('Database connected:', url)
})

db.on('error', err => {
  console.error('connection error:', err)
})
// end setup

// define mongoose schema
const Schema = mongoose.Schema

const item = new Schema({
  title: String
	task: String,
	date: String,
	urgency: Integer,
})

const TODO = mongoose.model("TODO", item)

// begin router
router.get("/", (req, res) => {
  // homepage
  res.send("smartDB API");
});

router.get("/db/all", (req, res) => {
		TODO.find().then((todos) => {
      res.json({ message: 'Return all todos.', todos: todos});
    })
});

// Combining endpoints into a single "route"

router.route("/db/:id")
	.get((req, res) => {
		TODO.findById(req.params.id, (error, todo) => {
			if (error) {
					res.status(500).json({ status: "failure" })
			} else {
					res.json(todo)
	  }
	}).
	.put("/db/:id", (req, res) => {
	  TODO.findByIdAndUpdate(req.params.id, req.body, (error, todo) => {
			if (error) {
				res.status(500).json({ status: "failure" })
			else {
				res.status(200).json(todo)
			}
	});
	.delete("/db/:id", (req, res) => {
		TODO.findByIdAndDelete(req.params.id, (error, todo) => {
			if (error) {
				res.status(500).json({ status: "failure"})
			} else {
				res.json(todo)
			}
	})

// POST Requests

router.post("/db", (req, res) => {
  const todo = TODO({        // Create TODO item with the appropriate fields
		title: req.body.title,
		task: req.body.task,
		date: req.body.date,
		urgency: req.body.urgency,
	})
	todo.save((error, document) => {
		res.json({               // Save TODO item to the database
			status: "success",
			id: todo._id,
			content: req.body
		)
	)
});

// Server Setup

app.use('/', router)

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

## Errors

Part of proper programming practice is enforcing our REST API design principles. Part of that API design is ensuring that we are following the HTTPS best practices, and that includes sending error codes whenever 

# Resources

[Build a RESTful API Using Node and Express 4](https://scotch.io/tutorials/build-a-restful-api-using-node-and-express-4)

[What is REST](https://restfulapi.net/)

---

**Contributors**

- [Alex Wu](https://www.linkedin.com/in/jialin-wu-658929185/)
- Dhruv Vaish

## EXTRA:

```jsx
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

var port = process.env.PORT || 8080;

var router = express.Router();

// The method of the root url. Be friendly and welcome our user :)
router.get('/', function(req, res) {
    res.json({ message: 'Welcome to the TODO app.' });   
});

// /api/todos
// All HTTP methods under the /todos URL.
router.route('/todos')
  // This GET method is in charge of returnning all the todos.
  .get((req, res) => {
    res.json({ message: 'Return all todos.'});   
  })
  // This POST methods is used to create a new todo. 
  // Its request will have a body, containing the content of the new todo.
  .post((req, res) => {
    res.json({ 
      message: ('Create a new todo: ' + "1" + " - " + req.body.content),
      todo_id:  "1",
      content: req.body.content,
    }); 
  })

// All HTTP methods under the /todos/:todo_id URL.
// The /:todo_id is a parameter within the URL that specifies a particular todo.
router.route('/todos/:todo_id')
  // This GET method is used to get the content from a specific todo.
  .get((req, res) => {
    res.json({ message: 'Get the content from a todo.'});   
  })
  // We use PUT method to update a todo's content.
  .put((req, res) => {
    res.json({ 
              message: ('Update the todo: ' + req.params.todo_id + " - " + req.body.content),
              todo_id: req.params.todo_id,
              content: req.body.content,
            });   
  })
  // DELETE method is used to delete a todo.
  .delete((req, res) => {
    res.json({ message: 'Delete a todo.' }); 
  })

app.use('/api', router); // API Root url at: http://localhost:8080/api

app.listen(port);
console.log('Server listenning on port ' + port);
```

```bash
// All HTTP methods under the /todos URL.
router.route('/todos')
  // ...
  // This POST methods is used to create a new todo. 
  // Its request will have a body, containing the content of the new todo.
	.post((req, res) => {
    const todo = new TODO({
      content: req.body.content
    })
    todo.save((error, document) => {
      res.json({ 
        message: ('Create a new todo: ' + todo._id + " - " + req.body.content),
        todo_id:  todo._id,
        content: req.body.content,
      }); 
    })
  })

// All HTTP methods under the /todos/:todo_id URL.
// The /:todo_id is a parameter within the URL that specifies a particular todo.
router.route('/todos/:todo_id')
  // This GET method is used to get the content from a specific todo.
 .get((req, res) => {
    TODO.findById(req.params.todo_id, (err, todo) => {
	      if (err) {
        res.json({ message: 'Error when getting the content of the todo.'});
      }
      res.json({ message: 'Get the content from a todo.', todo});
    })
  })

// All HTTP methods under the /todos/:todo_id URL.
// The /:todo_id is a parameter within the URL that specifies a particular todo.
router.route('/todos/:todo_id')
  // ...
  // We use PUT method to update a todo's content.
  .put((req, res) => {
    TODO.findByIdAndUpdate(req.params.todo_id, {content: req.body.content}, (err, todo) => {
      if (err) {
        res.json({ message: 'Error when updating todo.'});
      }
      res.json({ message: 'Update the todo: ' + req.params.todo_id, old: todo, new: {_id: req.params.todo_id, content: req.body.content}});
    });
  })

// All HTTP methods under the /todos/:todo_id URL.
// The /:todo_id is a parameter within the URL that specifies a particular todo.
router.route('/todos/:todo_id')
	// ...
  // DELETE method is used to delete a todo.
  .delete((req, res) => {
    TODO.findByIdAndDelete(req.params.todo_id, (err, todo) => {
      if (err) {
        res.json({ message: 'Error when deleting todo.'});
      }
      res.json({ message: 'Delete the todo: ' + todo._id, todo: {_id: todo._id, content: todo.content}});
    });
  })
```

## Non-web servers

There are many servers out there that are NOT web servers! For example, Minecraft servers, Discord bots, and databases are all servers in some capacity.
All this means is that they are listening for requests from other computers, and responding to them on some port.
However, instead of sending back files, they are sending back other data.

For example, a Minecraft server will send back the Minecraft world, and a Discord bot will send back a message.

### Building a database

Databases are programs that run on your computer and store all your data for you.
As such, they are servers that listen for requests to store and retrieve data.
Your web server shouldn't have to bother itself with storing data, it should just ask the database to do it for it.
This isn't for just convenience, however:
 1. Databases are much more efficient at storing data than files. They can store and retrieve data much faster.
 2. Databases are much more reliable than files. They are designed to never lose data, even if your computer crashes half-way
 through writing a file.
 3. Databases are much more organized than files. They have a whole language for storing and retrieving data, and they can
  do it in a way that is much more efficient than files.

We will learn a lot more about databases later in the course, but for now, let's build a simple database to 
illustrate the point.

We will be building a "dumb" version of a database, meaning that we will be
emulating what a database would do with a very stupid implementation. We will
use a JSON object (dictionary) to store the items at a certain key and then return those
items as needed. As such, our database will be a key-value store.

### GET Requests

You may notice the world "get" in the syntax `app.get('/', (req, res) => {`. This is because there are actually
many different types of requests that clients can send us. These requests are part of the HTTP protocol.

The most common ones are `GET`, `POST`, `PUT`, and `DELETE`:
 1. `GET` is used to retrieve data from the server. For example, when you go to a website, your browser sends a `GET` request to the server to get the HTML file.
 2. `POST` is used to send data to the server. For example, when you fill out a form on a website, your browser sends a `POST` request to the server with the data you filled out.
 3. `PUT` is used to update data on the server. For example, when you edit your profile on a website, your browser sends a `PUT` request to the server with the new data.
 4. `DELETE` is used to delete data on the server. For example, when you delete a post on a website, your browser sends a `DELETE` request to the server with the ID of the post to delete.

Let's first implement the `GET` requests.

```jsx
const axios = require('axios');
const express = require('express');
const port = 3000;
const app = express();

app.use(express.json()); // Utilities for request bodies
app.use(express.urlencoded({ extended: true })); // Utilities for query params

stupidDB = {}; // initialize our dumb database

app.get('/db/all', (req, res) => {
  // get all items from the db
  res.send(stupidDB);
});

app.get('/db/:id', (req, res) => {
  // get a certain item from the db
  const id = req.params.id;
  if (id in stupidDB) {
    res.send(stupidDB[id]);
  } else {
    res.send({ error: 'no object found with this id' });
  }
});

app.listen(port, () => {
  console.log(`StupidDB listening at http://localhost:${port}`);
});
```

GET requests have a lot of flexibility and power in the way that we make them.
We can get information generically or we can encode the information that we want
into our API.

### POST & PUT Requests

```jsx
const axios = require('axios');
const express = require('express');
const port = 3000;
const app = express();

app.use(express.json()); // Utilities for request bodies
app.use(express.urlencoded({ extended: true })); // Utilities for query params

stupidDB = {}; // initialize our dumb database

app.get('/db/all', (req, res) => {
  // get all items from the db
  res.send(stupidDB);
});

app.get('/db/:id', (req, res) => {
  // get a certain item from the db
  const id = req.params.id;
  if (id in stupidDB) {
    res.send(stupidDB[id]);
  } else {
    res.send({ error: 'no object found with this id' });
  }
});

// POST Requests

app.post('/db/:id', (req, res) => {
  // Create item only if new
  const id = req.params.id; // get the index of the data to update
  const item = req.body.item; // access the body of the request which holds new data
  if (id in stupidDB) {
    res.send({ error: 'object already exists with this id' });
  } else {
    stupidDB[id] = item; // insert destructively
    res.send({ newItem: item });
  }
});

// PUT Requests

app.put('/db/:id', (req, res) => {
  const id = req.params.id; // get the index of the data to update
  const item = req.body.item; // access the body of the request which holds new data
  if (id in stupidDB) {
    stupidDB[id] = item; // insert destructively
    res.send({ newItem: item });
  } else {
    res.send({ error: 'no object found with this id' });
  }
});

app.listen(port, () => {
  console.log(`StupidDB listening at http://localhost:${port}`);
});
```

POST and PUT are, in my opinion, what separate a static website from a true web
application. POST and PUT are how we actually collect and store relevant data
for the user. They are the methods which give our website **functionality** _for
the user._

Let's look at POST first. To pass data along a POST request, we place data in
the body. Because we don't know the "shape" and size of our data, we utilize the
body as a sort of empty container to hold the data that we want to send. (Note:
It would be overkill to put request parameters into this space for GET
requests).

Exercise: Go to Postman and set up a POST request. Go to body and look at all of
the potential options for request bodies. By and large, we will be using "raw"
in this class. Click on raw and view the options in the dropdown for data
formats. Lot's of options! In this class, we will largely stick to JSON but if
you are curious, you can always explore others. (Note: other formats may require
extra setup on the Express side).

Now let's look at PUT. PUT is an excellent example of how versatile a request
is. In our PUT request, we use both url encoding and the body to send relevant
data to our server. In the URL, we put where we want the data to go, and in our
body we define what data we want to go there. This is exactly aligned to the
design principles we laid our for our GET and POST requests! With smarter design
we can vastly simplify the complexity of our systems.

Let's get some pictures from NASA using this API that they are providing and
send the descriptions back.

- [https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY](https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY)

To send a request to a particular api, we use the package called Axios. Remember
that we have already npm installed `axios` so it should be available for us to
use.

```bash
const express = require('express')
const app = express()
const port = 3000

const axios = require('axios');

app.get('/nasa', (req, res) => {
  axios.get('https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY')
  .then(response => {
    res.send(response.data);
  })
  .catch(error => {
    res.send(error);
  });
})
```

We will try to send an API request to NASA whenever a user visits the `/nasa`
route of our website.

Now to send an API request, we will use axios.get(). This will _send_ a `get`
request to the particular url provided.

Now go ahead and visit the
[`http://localhost:3000/nasa`](http://localhost:3000/nasa) url, you would find
this displaying on the screen.

![expected output](../assets/Lesson8/output.png)

We will learn more about API requests and web server in the future.

## Node and File System

Nodejs just like python, provides a very easy way to handle file system.

Let's build on top of the web server that we have. Say we want to build a API
where the user can input the name and type of a file and the server can create
it.

- [http://localhost:3000/create/?name=resume&type=txt](http://localhost:3000/create/?name=resume&type=txt)
- The API will look something like this, where the ? indicates parameters, and
  name=resume and type=txt are two of the parameters included in this API, they
  are connected by the & sign.

```jsx
app.get('/create', (req, res) => {
  let name = req.query.name;
  let type = req.query.type;
	...
})
```

In the `/create` route, we simply can access all the parameter like this.

Now, let us create a file using the file system package that node provides.

```jsx
const fs = require("fs");

...

app.get('/create', (req, res) => {
  let name = req.query.name;
  let type = req.query.type;
  let filename = name + '.' + type;
  fs.appendFile(filename, ' ', (err) => {
    if (err) res.send(err);
    res.send({
      "message": "File created!",
      "name": name,
      "type": type
    })
  })
})
```

The `fs.appendFile()` method creates a file with the given name in the current
folder that the server is in. Now try to visit
[`http://localhost:3000/create/?name=resume&type=txt`](http://localhost:3000/create/?name=resume&type=txt)
and see whether a file named resume.txt is created.


---

**Contributors**

- [Alex Wu](https://www.linkedin.com/in/jialin-wu-658929185/)